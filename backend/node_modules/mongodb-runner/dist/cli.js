"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const mongocluster_1 = require("./mongocluster");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const utilities = __importStar(require("./index"));
(async function () {
    const defaultRunnerDir = path_1.default.join(os_1.default.homedir(), '.mongodb', 'runner2');
    const argv = await yargs_1.default
        .version(false)
        .scriptName('mongodb-runner')
        .env('MONGODB_RUNNER')
        .option('topology', {
        alias: 't',
        choices: ['standalone', 'replset', 'sharded'],
        default: 'standalone',
        describe: 'Select a topology type',
    })
        .option('arbiters', {
        type: 'number',
        describe: 'number of arbiter nodes for each replica set',
    })
        .option('secondaries', {
        type: 'number',
        describe: 'number of secondaries for each replica set',
    })
        .option('shards', {
        type: 'number',
        describe: 'number of shards for sharded clusters',
    })
        .option('version', {
        type: 'string',
        describe: 'MongoDB server version to use',
    })
        .option('logDir', {
        type: 'string',
        describe: 'Directory to store server log files in',
    })
        .option('binDir', {
        type: 'string',
        describe: 'Directory containing mongod/mongos binaries',
    })
        .option('tmpDir', {
        type: 'string',
        default: os_1.default.tmpdir(),
        describe: 'Directory for temporary files',
    })
        .option('runnerDir', {
        type: 'string',
        default: defaultRunnerDir,
        describe: 'Directory for storing cluster metadata',
    })
        .option('docker', {
        type: 'string',
        describe: 'Docker image name to run server instances under',
    })
        .option('id', {
        type: 'string',
        describe: 'ID to save the cluster metadata under',
    })
        .option('all', {
        type: 'boolean',
        describe: 'for `stop`: stop all clusters',
    })
        .option('debug', { type: 'boolean', describe: 'Enable debug output' })
        .command('start', 'Start a MongoDB instance')
        .command('stop', 'Stop a MongoDB instance')
        .command('prune', 'Clean up metadata for any dead MongoDB instances')
        .command('ls', 'List currently running MongoDB instances')
        .command('exec', 'Run a process with a MongoDB instance (as MONGODB_URI env var)')
        .demandCommand(1, 'A command needs to be provided')
        .help().argv;
    const [command, ...args] = argv._.map(String);
    if (argv.debug) {
        debug_1.default.enable('mongodb-runner');
    }
    async function start() {
        const { cluster, id } = await utilities.start(argv, args);
        console.log(`Server started and running at ${cluster.connectionString}`);
        console.log('Run the following command to stop the instance:');
        console.log(`${argv.$0} stop --id=${id}` +
            (argv.runnerDir !== defaultRunnerDir
                ? `--runnerDir=${argv.runnerDir}`
                : ''));
        cluster.unref();
    }
    async function stop() {
        if (!argv.id && !argv.all) {
            throw new Error('Need --id or --all to know which server to stop');
        }
        await utilities.stop(argv);
    }
    async function ls() {
        for await (const { id, connectionString } of utilities.instances(argv)) {
            console.log(`${id}: ${connectionString}`);
        }
    }
    async function prune() {
        await utilities.prune(argv);
    }
    async function exec() {
        let mongodArgs;
        let execArgs;
        const doubleDashIndex = args.indexOf('--');
        if (doubleDashIndex !== -1) {
            mongodArgs = args.slice(0, doubleDashIndex);
            execArgs = args.slice(doubleDashIndex + 1);
        }
        else {
            mongodArgs = [];
            execArgs = args;
        }
        const cluster = await mongocluster_1.MongoCluster.start({
            ...argv,
            args: mongodArgs,
        });
        try {
            const [prog, ...progArgs] = execArgs;
            const child = (0, child_process_1.spawn)(prog, progArgs, {
                stdio: 'inherit',
                env: {
                    ...process.env,
                    MONGODB_URI: cluster.connectionString,
                    MONGODB_URL: cluster.connectionString,
                    MONGODB_HOSTPORT: cluster.hostport,
                },
            });
            [process.exitCode] = await (0, events_1.once)(child, 'exit');
        }
        finally {
            await cluster.close();
        }
    }
    async function unknown() {
        throw new Error(`Unknown command: ${command}. See '${argv.$0} --help' for more information.`);
    }
    await ({ start, stop, exec, ls, prune }[command] ?? unknown)();
})().catch((err) => {
    process.nextTick(() => {
        throw err;
    });
});
//# sourceMappingURL=cli.js.map