"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoCluster = void 0;
const mongoserver_1 = require("./mongoserver");
const mongodb_connection_string_url_1 = require("mongodb-connection-string-url");
const mongodb_downloader_1 = require("@mongodb-js/mongodb-downloader");
const mongodb_1 = require("mongodb");
const util_1 = require("./util");
class MongoCluster {
    constructor() {
        this.topology = 'standalone';
        this.servers = [];
        this.shards = [];
    }
    serialize() {
        return {
            topology: this.topology,
            replSetName: this.replSetName,
            servers: this.servers.map((srv) => srv.serialize()),
            shards: this.shards.map((shard) => shard.serialize()),
        };
    }
    isClosed() {
        return this.servers.length === 0 && this.shards.length === 0;
    }
    static async deserialize(serialized) {
        const cluster = new MongoCluster();
        cluster.topology = serialized.topology;
        cluster.replSetName = serialized.replSetName;
        cluster.servers = await Promise.all(serialized.servers.map((srv) => mongoserver_1.MongoServer.deserialize(srv)));
        cluster.shards = await Promise.all(serialized.shards.map((shard) => MongoCluster.deserialize(shard)));
        return cluster;
    }
    get hostport() {
        return this.servers.map((srv) => srv.hostport).join(',');
    }
    get connectionString() {
        return `mongodb://${this.hostport}/${this.replSetName ? `?replicaSet=${this.replSetName}` : ''}`;
    }
    get connectionStringUrl() {
        return new mongodb_connection_string_url_1.ConnectionString(this.connectionString);
    }
    get serverVersion() {
        return this.servers[0].serverVersion;
    }
    get serverVariant() {
        return this.servers[0].serverVariant;
    }
    static async start({ ...options }) {
        const cluster = new MongoCluster();
        cluster.topology = options.topology;
        if (!options.binDir) {
            options.binDir = await (0, mongodb_downloader_1.downloadMongoDb)(options.tmpDir, options.version, options.downloadOptions);
        }
        if (options.topology === 'standalone') {
            cluster.servers.push(await mongoserver_1.MongoServer.start({
                ...options,
                binary: 'mongod',
            }));
        }
        else if (options.topology === 'replset') {
            const { secondaries = 2, arbiters = 0 } = options;
            const args = [...(options.args ?? [])];
            let replSetName;
            if (!args.includes('--replSet')) {
                replSetName = `replSet-${(0, util_1.uuid)()}`;
                args.push('--replSet', replSetName);
            }
            else {
                replSetName = args[args.indexOf('--replSet') + 1];
            }
            const primaryArgs = [...args];
            (0, util_1.debug)('Starting primary', primaryArgs);
            const primary = await mongoserver_1.MongoServer.start({
                ...options,
                args: primaryArgs,
                binary: 'mongod',
            });
            cluster.servers.push(primary);
            if (args.includes('--port')) {
                args.splice(args.indexOf('--port') + 1, 1, '0');
            }
            (0, util_1.debug)('Starting secondaries and arbiters', {
                secondaries,
                arbiters,
                args,
            });
            cluster.servers.push(...(await Promise.all((0, util_1.range)(secondaries + arbiters).map(() => mongoserver_1.MongoServer.start({
                ...options,
                args,
                binary: 'mongod',
            })))));
            await primary.withClient(async (client) => {
                (0, util_1.debug)('Running rs.initiate');
                const rsConf = {
                    _id: replSetName,
                    configsvr: args.includes('--configsvr'),
                    members: cluster.servers.map((srv, i) => {
                        return {
                            _id: i,
                            host: srv.hostport,
                            arbiterOnly: i > 1 + secondaries,
                            priority: i === 0 ? 1 : 0,
                        };
                    }),
                };
                await client.db('admin').command({
                    replSetInitiate: rsConf,
                });
                for (let i = 0; i < 60; i++) {
                    const status = await client.db('admin').command({
                        replSetGetStatus: 1,
                    });
                    if (status.members.some((member) => member.stateStr === 'PRIMARY')) {
                        (0, util_1.debug)('rs.status indicated primary for replset', status.set);
                        cluster.replSetName = status.set;
                        break;
                    }
                    (0, util_1.debug)('rs.status did not include primary, waiting...');
                    await (0, util_1.sleep)(1000);
                }
            });
        }
        else if (options.topology === 'sharded') {
            const { shards = 3 } = options;
            const shardArgs = [...(options.args ?? [])];
            if (shardArgs.includes('--port')) {
                shardArgs.splice(shardArgs.indexOf('--port') + 1, 1, '0');
            }
            (0, util_1.debug)('starting config server and shard servers', shardArgs);
            const [configsvr, ...shardsvrs] = await Promise.all((0, util_1.range)(shards + 1).map((i) => MongoCluster.start({
                ...options,
                args: [...shardArgs, i > 0 ? '--shardsvr' : '--configsvr'],
                topology: 'replset',
            })));
            cluster.shards.push(configsvr, ...shardsvrs);
            (0, util_1.debug)('starting mongos');
            const mongos = await mongoserver_1.MongoServer.start({
                ...options,
                binary: 'mongos',
                args: [
                    ...(options.args ?? []),
                    '--configdb',
                    `${configsvr.replSetName}/${configsvr.hostport}`,
                ],
            });
            cluster.servers.push(mongos);
            await mongos.withClient(async (client) => {
                for (const shard of shardsvrs) {
                    const shardSpec = `${shard.replSetName}/${shard.hostport}`;
                    (0, util_1.debug)('adding shard', shardSpec);
                    await client.db('admin').command({
                        addShard: shardSpec,
                    });
                }
                (0, util_1.debug)('added shards');
            });
        }
        return cluster;
    }
    async close() {
        await Promise.all([...this.servers, ...this.shards].map((closable) => closable.close()));
        this.servers = [];
        this.shards = [];
    }
    async withClient(fn, clientOptions = {}) {
        const client = await mongodb_1.MongoClient.connect(this.connectionString, clientOptions);
        try {
            return await fn(client);
        }
        finally {
            await client.close(true);
        }
    }
    ref() {
        for (const child of [...this.servers, ...this.shards])
            child.ref();
    }
    unref() {
        for (const child of [...this.servers, ...this.shards])
            child.unref();
    }
}
exports.MongoCluster = MongoCluster;
//# sourceMappingURL=mongocluster.js.map