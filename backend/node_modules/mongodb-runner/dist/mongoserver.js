"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoServer = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const mongologreader_1 = require("./mongologreader");
const stream_1 = require("stream");
const mongodb_1 = require("mongodb");
const path_1 = __importDefault(require("path"));
const events_1 = require("events");
const util_1 = require("./util");
class MongoServer {
    constructor() {
        this.closing = false;
    }
    serialize() {
        return {
            pid: this.pid,
            port: this.port,
            dbPath: this.dbPath,
        };
    }
    static async deserialize(serialized) {
        const srv = new MongoServer();
        srv.pid = serialized.pid;
        srv.port = serialized.port;
        srv.dbPath = serialized.dbPath;
        await srv._populateBuildInfo();
        return srv;
    }
    get hostport() {
        if (this.port === undefined) {
            throw new Error('Cannot get host/port for closed server');
        }
        return `127.0.0.1:${this.port}`;
    }
    get serverVersion() {
        if (!this.buildInfo) {
            throw new Error('Cannot get version for closed server');
        }
        return this.buildInfo.version;
    }
    get serverVariant() {
        if (!this.buildInfo) {
            throw new Error('Cannot get version for closed server');
        }
        return this.buildInfo.modules?.includes?.('enterprise')
            ? 'enterprise'
            : 'community';
    }
    static async start({ ...options }) {
        if (options.binary === 'mongos' && !options.args?.includes('--port')) {
            const minPort = 1025;
            const maxPort = 49151;
            let port = Math.floor(Math.random() * (maxPort - minPort) + minPort);
            while (true) {
                try {
                    (0, util_1.debug)('Trying to spawn mongos on port', port);
                    return await this._start({
                        ...options,
                        args: [...(options.args ?? []), '--port', String(port)],
                    });
                }
                catch (err) {
                    if (err.errorLogEntries.some(mongologreader_1.isFailureToSetupListener)) {
                        if (port === maxPort)
                            port = minPort;
                        else
                            port++;
                        continue;
                    }
                    throw err;
                }
            }
        }
        return await this._start(options);
    }
    static async _start({ ...options }) {
        const srv = new MongoServer();
        if (!options.docker) {
            const dbPath = path_1.default.join(options.tmpDir, `db-${(0, util_1.uuid)()}`);
            await fs_1.promises.mkdir(dbPath, { recursive: true });
            srv.dbPath = dbPath;
        }
        const commandline = [];
        if (options.docker) {
            commandline.push('docker', 'run', '--network=host');
            if (options.binDir) {
                commandline.push(`--volume=${options.binDir}:/runner-bin:ro`);
            }
            if (Array.isArray(options.docker))
                commandline.push(...options.docker);
            else
                commandline.push(options.docker);
            if (options.binDir) {
                commandline.push(`/runner-bin/${options.binary}`);
            }
            else {
                commandline.push(options.binary);
            }
        }
        else if (options.binDir) {
            commandline.push(path_1.default.join(options.binDir, options.binary));
        }
        else {
            commandline.push(options.binary);
        }
        commandline.push(...(options.args ?? []));
        if (!options.args?.includes('--port'))
            commandline.push('--port', '0');
        if (!options.args?.includes('--dbpath') && options.binary === 'mongod')
            commandline.push('--dbpath', options.docker ? '/tmp' : srv.dbPath);
        if (!options.args?.includes('--unixSocketPrefix') &&
            process.platform !== 'win32')
            commandline.push('--nounixsocket');
        (0, util_1.debug)('starting server', commandline);
        const [executable, ...args] = commandline;
        const proc = (0, child_process_1.spawn)(executable, args, {
            stdio: ['inherit', 'pipe', 'pipe'],
            cwd: options.tmpDir,
            detached: true,
        });
        await (0, events_1.once)(proc, 'spawn');
        srv.childProcess = proc;
        srv.pid = proc.pid;
        const { stdout, stderr } = proc;
        stdout.setEncoding('utf8');
        stderr.setEncoding('utf8');
        if (options.logDir) {
            const outFile = path_1.default.join(options.logDir, `${options.binary}-${String(proc.pid)}-${new Date()
                .toISOString()
                .replace(/[^-_a-zA-Z0-9.]/g, '')}.log`);
            await fs_1.promises.mkdir(options.logDir, { recursive: true });
            const outStream = (0, fs_1.createWriteStream)(outFile);
            await (0, events_1.once)(outStream, 'open');
            stdout.pipe(outStream, { end: false });
            stderr.pipe(outStream, { end: false });
            Promise.all([(0, events_1.once)(stdout, 'end'), (0, events_1.once)(stderr, 'end')]).then(() => outStream.end(), () => {
            });
        }
        else {
            stderr.on('data', (chunk) => (0, util_1.debug)('server stderr', chunk));
            stderr.resume();
            stdout.resume();
        }
        const errorLogEntries = [];
        try {
            const logEntryStream = stream_1.Readable.from((0, mongologreader_1.createLogEntryIterator)(stdout));
            logEntryStream.on('data', (entry) => {
                if (!srv.closing && ['E', 'F'].includes(entry.severity)) {
                    errorLogEntries.push(entry);
                    (0, util_1.debug)('mongodb server output', entry);
                }
            });
            (0, mongologreader_1.filterLogStreamForBuildInfo)(logEntryStream).then((buildInfo) => {
                (srv.buildInfo = buildInfo),
                    (0, util_1.debug)('got server build info from log', srv.serverVersion, srv.serverVariant);
            }, () => {
            });
            const { port } = await (0, mongologreader_1.filterLogStreamForPort)(logEntryStream);
            (0, util_1.debug)('server listening on port', port);
            if (port === -1) {
                let message = 'Server log output did not include port or socket';
                if (errorLogEntries.length > 0) {
                    const format = (entry) => `${entry.message} ${JSON.stringify(entry.attr)}`;
                    message = `Server failed to start: ${errorLogEntries
                        .map(format)
                        .join(', ')} from ${commandline.join(' ')})`;
                }
                const err = new Error(message);
                err.errorLogEntries = errorLogEntries;
                throw err;
            }
            logEntryStream.resume();
            srv.port = port;
            await srv._populateBuildInfo();
        }
        catch (err) {
            await srv.close();
            throw err;
        }
        return srv;
    }
    async close() {
        this.closing = true;
        if (this.childProcess) {
            (0, util_1.debug)('closing running process', this.childProcess.pid);
            if (this.childProcess.exitCode === null &&
                this.childProcess.signalCode === null) {
                this.childProcess.kill('SIGKILL');
                await (0, events_1.once)(this.childProcess, 'exit');
            }
            (0, util_1.debug)('stopped running process');
            this.childProcess = undefined;
        }
        else if (this.pid !== undefined) {
            (0, util_1.debug)('closing externally started process', this.pid);
            process.kill(this.pid, 'SIGKILL');
        }
        try {
            if (this.dbPath)
                await fs_1.promises.rm(this.dbPath, { recursive: true });
        }
        catch (err) {
            (0, util_1.debug)('failed to remove dbPath', err);
        }
        this.buildInfo = undefined;
        this.port = undefined;
        this.dbPath = undefined;
    }
    async _populateBuildInfo() {
        if (this.buildInfo?.version)
            return;
        this.buildInfo = await this.withClient(async (client) => await client.db('admin').command({ buildInfo: 1 }));
        (0, util_1.debug)('got server build info through client', this.serverVersion, this.serverVariant);
    }
    async withClient(fn) {
        const client = await mongodb_1.MongoClient.connect(`mongodb://${this.hostport}/?directConnection=true`);
        try {
            return await fn(client);
        }
        finally {
            await client.close(true);
        }
    }
    ref() {
        this.childProcess?.ref();
        this.childProcess?.stdout?.ref();
        this.childProcess?.stderr?.ref();
    }
    unref() {
        this.childProcess?.unref();
        this.childProcess?.stdout?.unref();
        this.childProcess?.stderr?.unref();
    }
}
exports.MongoServer = MongoServer;
//# sourceMappingURL=mongoserver.js.map