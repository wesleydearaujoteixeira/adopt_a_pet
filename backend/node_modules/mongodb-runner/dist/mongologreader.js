"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterLogStreamForBuildInfo = exports.filterLogStreamForPort = exports.isFailureToSetupListener = exports.parseAnyLogEntry = exports.createLogEntryIterator = void 0;
const stream_1 = require("stream");
const readline_1 = require("readline");
async function* createLogEntryIterator(stdout) {
    for await (const line of (0, readline_1.createInterface)({ input: stdout })) {
        if (!line.trim()) {
            continue;
        }
        try {
            const logEntry = parseAnyLogEntry(line);
            yield logEntry;
        }
        catch (error) {
            break;
        }
    }
}
exports.createLogEntryIterator = createLogEntryIterator;
function parseOldLogEntry(line) {
    const re = /^(?<timestamp>\S*) *(?<severity>\S*) *(?<component>\S*) *\[(?<context>[^\]]+)\]\s*(?<message>.*)$/;
    const match = re.exec(line.trim());
    if (!match) {
        throw new Error(`Could not parse line ${JSON.stringify(line)}`);
    }
    return match.groups;
}
function parseAnyLogEntry(line) {
    try {
        const newFormat = JSON.parse(line);
        return {
            id: newFormat.id,
            timestamp: newFormat.t?.$date,
            severity: newFormat.s,
            component: newFormat.c,
            context: newFormat.ctx,
            message: newFormat.msg,
            attr: newFormat.attr,
        };
    }
    catch {
        return parseOldLogEntry(line);
    }
}
exports.parseAnyLogEntry = parseAnyLogEntry;
function isFailureToSetupListener(entry) {
    return (entry.id === 22856 ||
        entry.message.includes('Failed to set up listener'));
}
exports.isFailureToSetupListener = isFailureToSetupListener;
function getPortFromLogEntry(logEntry) {
    let match;
    if (logEntry.id === 23016) {
        return logEntry.attr.port;
    }
    if (logEntry.id === undefined &&
        (match = /^waiting for connections on port (?<port>\d+)( ssl)?$/i.exec(logEntry.message))) {
        return +(match.groups?.port ?? '0');
    }
    if (isFailureToSetupListener(logEntry)) {
        throw new Error(`Failed to setup listener (${logEntry.message} ${JSON.stringify(logEntry.attr)})`);
    }
    return -1;
}
async function filterLogStreamForPort(input) {
    let port = -1;
    const inputDuplicate = input.pipe(new stream_1.PassThrough({ objectMode: true }));
    try {
        for await (const logEntry of inputDuplicate) {
            if (logEntry.component !== 'NETWORK' ||
                !['initandlisten', 'listener', 'mongosMain'].includes(logEntry.context)) {
                continue;
            }
            port = getPortFromLogEntry(logEntry);
            if (port !== -1) {
                break;
            }
        }
    }
    finally {
        input.unpipe(inputDuplicate);
    }
    return { port };
}
exports.filterLogStreamForPort = filterLogStreamForPort;
function getBuildInfoFromLogEntry(logEntry) {
    let match;
    if (logEntry.id === 23403) {
        return logEntry.attr.buildInfo;
    }
    if (logEntry.id === undefined &&
        (match = /^(?:db|mongos) version v(?<version>.+)$/i.exec(logEntry.message))) {
        return { version: match.groups?.version };
    }
    if (logEntry.id === undefined &&
        (match = /^modules: (?<moduleList>.+)$/i.exec(logEntry.message))) {
        return {
            modules: match.groups?.moduleList
                ?.split(' ')
                ?.filter((module) => module !== 'none'),
        };
    }
    return {};
}
async function filterLogStreamForBuildInfo(input) {
    let buildInfo = { version: null, modules: null };
    const inputDuplicate = input.pipe(new stream_1.PassThrough({ objectMode: true }));
    try {
        for await (const logEntry of inputDuplicate) {
            if (logEntry.component !== 'CONTROL' ||
                !['initandlisten', 'listener'].includes(logEntry.context)) {
                continue;
            }
            buildInfo = { ...buildInfo, ...getBuildInfoFromLogEntry(logEntry) };
            if (buildInfo.version) {
                break;
            }
        }
    }
    finally {
        input.unpipe(inputDuplicate);
    }
    return buildInfo;
}
exports.filterLogStreamForBuildInfo = filterLogStreamForBuildInfo;
//# sourceMappingURL=mongologreader.js.map