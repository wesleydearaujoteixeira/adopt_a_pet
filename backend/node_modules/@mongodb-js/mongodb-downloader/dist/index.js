"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadMongoDb = exports.downloadMongoDbWithVersionInfo = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const tar_1 = __importDefault(require("tar"));
const util_1 = require("util");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const decompress_1 = __importDefault(require("decompress"));
const stream_1 = require("stream");
const mongodb_download_url_1 = __importDefault(require("mongodb-download-url"));
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('mongodb-downloader');
async function downloadMongoDbWithVersionInfo(tmpdir, targetVersionSemverSpecifier = '*', options = {}) {
    let wantsEnterprise = options.enterprise ?? false;
    const isWindows = ['win32', 'windows'].includes(options.platform ?? process.platform);
    async function lookupDownloadUrl() {
        return await (0, mongodb_download_url_1.default)({
            version: targetVersionSemverSpecifier,
            enterprise: wantsEnterprise,
            ...options,
        });
    }
    await fs_1.promises.mkdir(tmpdir, { recursive: true });
    if (targetVersionSemverSpecifier === 'latest-alpha') {
        return await doDownload(tmpdir, !!options.crypt_shared, 'latest-alpha', isWindows, lookupDownloadUrl);
    }
    if (/-enterprise$/.test(targetVersionSemverSpecifier)) {
        wantsEnterprise = true;
        targetVersionSemverSpecifier = targetVersionSemverSpecifier.replace(/-enterprise$/, '');
    }
    return await doDownload(tmpdir, !!options.crypt_shared, targetVersionSemverSpecifier +
        (wantsEnterprise ? '-enterprise' : '-community'), isWindows, () => lookupDownloadUrl());
}
exports.downloadMongoDbWithVersionInfo = downloadMongoDbWithVersionInfo;
const downloadPromises = Object.create(null);
async function doDownload(tmpdir, isCryptLibrary, version, isWindows, lookupDownloadUrl) {
    const downloadTarget = path_1.default.resolve(tmpdir, `mongodb-${process.platform}-${process.env.DISTRO_ID || 'none'}-${process.arch}-${version}`.replace(/[^a-zA-Z0-9_-]/g, ''));
    return (downloadPromises[downloadTarget] ?? (downloadPromises[downloadTarget] = (async () => {
        const bindir = path_1.default.resolve(downloadTarget, isCryptLibrary && !isWindows ? 'lib' : 'bin');
        const artifactInfoFile = path_1.default.join(bindir, '.artifact_info');
        try {
            await fs_1.promises.stat(artifactInfoFile);
            debug(`Skipping download because ${downloadTarget} exists`);
            return {
                ...JSON.parse(await fs_1.promises.readFile(artifactInfoFile, 'utf8')),
                downloadedBinDir: bindir,
            };
        }
        catch {
        }
        await fs_1.promises.mkdir(downloadTarget, { recursive: true });
        const artifactInfo = await lookupDownloadUrl();
        const { url } = artifactInfo;
        debug(`Downloading ${url} into ${downloadTarget}...`);
        const HWM = 1024 * 1024;
        async function downloadAndExtract(withExtraStripDepth = 0) {
            const response = await (0, node_fetch_1.default)(url, {
                highWaterMark: HWM,
            });
            if (/\.tgz$|\.tar(\.[^.]+)?$/.exec(url)) {
                await (0, util_1.promisify)(stream_1.pipeline)(response.body, tar_1.default.x({ cwd: downloadTarget, strip: isCryptLibrary ? 0 : 1 }));
            }
            else {
                const filename = path_1.default.join(downloadTarget, path_1.default.basename(new URL(url).pathname));
                await (0, util_1.promisify)(stream_1.pipeline)(response.body, (0, fs_1.createWriteStream)(filename, { highWaterMark: HWM }));
                debug(`Written file ${url} to ${filename}, extracting...`);
                await (0, decompress_1.default)(filename, downloadTarget, {
                    strip: isCryptLibrary ? 0 : 1,
                    filter: (file) => path_1.default.extname(file.path) !== '.pdb',
                });
            }
            try {
                await fs_1.promises.stat(bindir);
            }
            catch (err) {
                if (withExtraStripDepth === 0 && url.includes('macos')) {
                    console.info('Retry due to miscalculated --strip-components depth');
                    return await downloadAndExtract(1);
                }
                throw err;
            }
        }
        await downloadAndExtract();
        await fs_1.promises.writeFile(artifactInfoFile, JSON.stringify(artifactInfo));
        debug(`Download complete`, bindir);
        return { ...artifactInfo, downloadedBinDir: bindir };
    })()));
}
async function downloadMongoDb(...args) {
    return (await downloadMongoDbWithVersionInfo(...args)).downloadedBinDir;
}
exports.downloadMongoDb = downloadMongoDb;
//# sourceMappingURL=index.js.map